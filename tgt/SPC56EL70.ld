/*
    SPC5 HAL - Copyright (C) 2013 STMicroelectronics

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/*
 * This file is automatically generated and can be overwritten, do no change
 * this file manually.
 */

/*
 * SPC56EL60 memory setup in LSM mode.
 */
CONSTANTS{
__irq_stack_size__      = 0;
__process_stack_size__  = 2048;
/*
 * Derived constants.
 */

}
MEMORY
{
    flash_boot	: org = 0x00000000, len = 12
    flash     	: org  = 0x0000000c, len = 1M-12
//theoretically if the code section overlaps with the interrupt table then the linker should give an error
// BEWARE in case it doesnt and code size exceeds 1M-12-0x2000 (0x2000 is size of interrupt tables section)
//incase it gives an error then the interrupt tables must be moved to some other section of the flash
    ram       	: org = 0x40000000, len = 128k
}

//REGION_ALIAS("INTR", interrupts_rom)



SECTIONS
{
     __flash_start__         = ADDR(flash);
     __flash_end__           = ENDADDR(flash);

     __ram_start__           = ADDR(ram);
     __ram_end__             = ENDADDR(ram);

      
    .boot  ALIGN(16) : {
        *(.boot)
        *(.branch_reset)
    } > flash_boot


    .code : 
    {    
      _reset_address = .;
      *(.crt0)
      *(.vletext)
      *(.vletext.memcpy)  /*on including GTM module it asked for .text_vle.memcpy in linker*/
      . = ALIGN(16);
    } >  flash
         
    .text  ALIGN(16):
    {
        *(.text)
	*(.gnu.linkonce.t)
    } > flash

    .rodata  ALIGN(16):
    {
        *(.glue_7t)
        *(.glue_7)
	*(.gcc)
        *(.rodata)
        *(.rodata1)
    } > flash

    .sdata2  ALIGN(16):
    {
        __sdata2_start__ = . + 0x8000;
        *(.sdata2)
        *(.gnu.linkonce.s2)
	*(.sbss2)
	*(.gnu.linkonce.sb2)
    } > flash

    .romdata  ALIGN(16) :
    {
        __romdata_start__ = .;
    } > flash

//this must only be done when everything has been writtnen to the flash
//theoretically if the code section overlaps with the interrupt table then the linker should give an error
// BEWARE in case it doesnt and code size exceeds 1M-12-0x2000
//incase it gives an error then the interrupt tables must be moved to some other section of the flash
    .isrVectorTable ALIGN(65536) :
    {
    	__IVPR_BASE_ = .;
    	*(.isrTrapTable)
      	. = ALIGN(2048) ;
      	__ISR_BASE_ = .;
      	*(.interrupt_table)
	} > flash

//RAM starts here
    .stacks  ALIGN(16):
    {
        . = ALIGN(8);
        __irq_stack_base__ = .;
        . += __irq_stack_size__;
        . = ALIGN(8);
        __irq_stack_end__ = .;
        __process_stack_base__ = .;
        __main_thread_stack_base__ = .;
        . += __process_stack_size__;
        . = ALIGN(8);
        __process_stack_end__ = .;
        __main_thread_stack_end__ = .;
    } > ram
    
    
    .data : AT(__romdata_start__)
    {
        . = ALIGN(4);
        __data_start__ = .;
        *(.data)
        __data_end__ = .;
    } > ram

    .sdata :
    {
        __sdata_start__ = . + 0x8000;
	*(.sdata)
        __sdata_end__ = .;
    } > ram

    .sbss :
    {
        __bss_start__ = .;
        *(.sbss)
        *(.gnu.linkonce.sb)
        *(.scommon)
    } > ram

    .bss :
    {
        *(.bss)
	*(.gnu.linkonce.b)
        *(COMMON)
        __bss_end__ = .;
    } > ram
    _start = _reset_address;
    __heap_base__   = __bss_end__;
    __heap_end__    = __ram_end__;
}
